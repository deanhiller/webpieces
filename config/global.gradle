//Have to do this on EACH project so it will transitively pick it up
clean.dependsOn gradle.includedBuilds*.task(':clean')
build.dependsOn gradle.includedBuilds*.task(':build')
test.dependsOn gradle.includedBuilds*.task(':test')

//gradle.taskGraph. { taskGraph ->
//}

sourceCompatibility = JavaVersion.VERSION_11
targetCompatibility = JavaVersion.VERSION_11

repositories {
    mavenCentral()
    maven {
        //for testing local manually or publishing plugin
        name "webpiecesLocal1"
        url uri('/tmp/myRepo/')
    }
}

//Have to ignore the template projects which violate checkstyle until used to create
//customers projects
if (!project.name.contains("production") && !project.name.contains("development")) {
    System.out.println("proj name=" + project.name)
    checkstyle {
        configFile = rootProject.file('../../config/checkstyle.xml')
    }
}

//MUST be defined here or every project has to override groupId in pom which is super annoying
if(group == null || group.isBlank()) {
    group = 'org.webpieces'
}

ext {
    // Project constants
    sonatypeDomain = "s01.oss.sonatype.org"

    //This is an input directory that we read jars from if they are not in a repo somewhere
    fixedLibDir = file('lib')
    toStagingDir = file(new File(buildDir, 'alljars'))
    github_org = 'deanhiller'
    project_name = 'webpieces'
    getCommitHash = {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'rev-parse', 'HEAD'
            standardOutput = stdout
        }
        return stdout.toString().trim()
    }.memoize()

}

if (project.hasProperty('projVersion')) {
    println("Java Version=" + System.getProperty("java.version"))
}

gradle.taskGraph.whenReady { taskGraph ->
    if (taskGraph.hasTask(publish)) {
        println("graph has task PUBLISH!!!")
        if (!project.hasProperty('projVersion')) {
            throw new RuntimeException("You must have -PprojVersion set to run the publish task which your task depends on as sonas needs release numbers")
        }
    }
}

def currentJvm = System.getProperty('java.version') + ' (' + System.getProperty('java.vendor') + ' ' + System.getProperty('java.runtime.version') + ')'

if (project.hasProperty('projVersion')) {
    if (project.projVersion.replaceAll("[^.]", "").length() < 2) {
        throw new GradleException("projVersion must be the full version!")
    }
    project.version = project.projVersion
    println("CREATING RELEASE VERSION " + project.name + ":" + project.version + "  jvm=" + currentJvm)
} else {
    project.version = '2.1-developer'
    println("CREATING DEVELOPER VERSION " + project.name + ":" + project.version + "  jvm=" + currentJvm)
}

dependencies {

    /**************************************************************************
     * DO NOT ADD HERE
     * Adding here results in adding deps to EVERY project and we want
     * lightweight re-usable jars
     ***********************************************************************/

    testImplementation libs.junit

}

configurations.all {

    resolutionStrategy {

        eachDependency { DependencyResolveDetails details ->

            if (details.requested.group == 'com.google.guava' && details.requested.version.contains('android')) {
                details.useVersion details.requested.version.replace('android', 'jre')
                details.because 'we want the JRE version of Guava'
            }

        }

    }
}

pluginManager.withPlugin('java') {

    sourceCompatibility = '11'
    targetCompatibility = '11'

    [compileJava, compileTestJava]*.options.collect { options ->
        options.compilerArgs.add '-parameters'
        options.encoding = 'UTF-8'
    }

}

if (JavaVersion.current().isJava8Compatible()) {
    tasks.withType(Javadoc) {
        // disable the crazy super-strict doclint tool in Java 8
        //noinspection SpellCheckingInspection
        options.addStringOption('Xdoclint:none', '-quiet')
    }
}
if (JavaVersion.current().isJava9Compatible()) {
    tasks.withType(Javadoc) {
        options.addBooleanOption('html5', true)
    }
}

jar {
    manifest {
        attributes(
                'Implementation-Title': project.name,
                'Implementation-Version': project.version,
                'SCM-Revision': getCommitHash()
        )
    }
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    archiveClassifier = 'javadoc'
    from 'build/docs/javadoc'
    manifest {
        attributes(
                'Implementation-Title': project.name,
                'Implementation-Version': project.version,
                'SCM-Revision': getCommitHash()
        )
    }
}


jacocoTestReport {
    additionalSourceDirs.setFrom files(sourceSets.main.allSource.srcDirs)
    sourceDirectories.setFrom files(sourceSets.main.allSource.srcDirs)
    classDirectories.setFrom files(sourceSets.main.output)
/*
      classDirectories = files(sourceSets.main.output.filter { file ->
         if(file.getName().endsWith("Exception.class")) {
            print("Excluded:"+file.getName());
            return false;
         }
         print("Included:"+file.getName());
         return true;
      })
*/
    executionData.from = fileTree(buildDir).include("/jacoco/*.exec")
    reports {
        html.required = true
        xml.required = true
        csv.required = false
    }
}

jacocoTestReport.dependsOn test
check.dependsOn jacocoTestReport

task sourcesJar(type: Jar) {
    duplicatesStrategy = DuplicatesStrategy.WARN
    archiveClassifier = 'sources'
    from sourceSets.main.allSource
    manifest {
        attributes(
                'Implementation-Title': project.name,
                'Implementation-Version': project.version,
                'SCM-Revision': getCommitHash()
        )
    }
}

//This is really only needed for devrouter, embeddablewebserver, http-client, and embeddablehttpproxy
//I wonder if we can list out those few projects and this task to each one and the assemble.dependsOn as well
//let's at least copy all jars to a single directory to use in creating an application...
//ALSO, this DELETES jars we no longer use so it has to be different directory than the dest jar we are creating as well
task syncJars(type: Sync, dependsOn: 'jar') {
    duplicatesStrategy = DuplicatesStrategy.WARN
    from(configurations.compileClasspath)
    from(fixedLibDir) {}
    from("${buildDir}/${libsDirName}") {}
    into toStagingDir
}

//processResources.dependsOn(":webserver:http-webserver:writeVersion")
assemble.dependsOn('syncJars')

test {
    //Tests fail with wifi OFF and ipv6....force ipv4 for now
    systemProperty "java.net.preferIPv4Stack", true

    beforeTest { descr ->
        logger.warn("Starting Test ${descr.className} : ${descr.name}")
    }
    afterTest { descr, result ->
        def totalTime = result.endTime - result.startTime
        logger.warn("Test complete ${descr.className} : ${descr.name} TOTAL TIME=${totalTime}")
    }
    testLogging {
        events "failed"
        exceptionFormat "full"
        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                println "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
            }
        }
    }
}

//Using eclipse bin folder is WAY too common.  use outputeclipse instead so we can safely ignore it
eclipse {
    classpath {
        defaultOutputDir = file('eclipse-output')
    }
}

eclipseProject {
    doLast {
        // https://discuss.gradle.org/t/how-to-write-properties-to-3rd-party-eclipse-settings-files/6499/2

        def props = new Properties()
        file(".settings/org.eclipse.jdt.core.prefs").withInputStream {
            stream -> props.load(stream)
        }
        props.setProperty("org.eclipse.jdt.core.compiler.codegen.methodParameters", "generate")
        file(".settings/org.eclipse.jdt.core.prefs").withOutputStream {
            stream -> props.store(stream, null)
        }
    }
}

pluginManager.withPlugin('maven-publish') {

    publishing {
        repositories {
            maven {
                name = 'webpiecesLocal2'
                url = "file:/tmp/myRepo/"
            }
        }
        publications {
            mavenJava(MavenPublication) {
                from components.java
                groupId group
                versionMapping {
                    usage('java-api') {
                        fromResolutionOf('runtimeClasspath')
                    }
                    usage('java-runtime') {
                        fromResolutionResult()
                    }
                }
                pom {
                    name = project.name
                    description = "Not filled in for this project"
                    //'Someone forgot to fill this in.  See http://stackoverflow.com/questions/38272550/how-to-fail-the-gradle-build-if-subproject-is-missing-a-property'
                    url = "https://github.com/${github_org}/${project_name}"
                    licenses {
                        license {
                            name = "The Apache License, Version 2.0"
                            url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
                        }
                    }
                    developers {
                        developer {
                            id = 'dhiller'
                            name = 'Dean Hiller'
                        }
                        developer {
                            id = 'zreed'
                            name = 'Zachary Reed'
                        }
                    }
                    scm {
                        connection = "scm:git:https://github.com/${github_org}/${project_name}.git"
                        developerConnection = "scm:git:git@github.com:${github_org}/${project_name}.git"
                        url = "https://github.com/${github_org}/${project_name}.git"
                    }
                }

                artifact sourcesJar
                artifact javadocJar
            }
        }
    }

    publishMavenJavaPublicationToWebpiecesLocal2Repository.dependsOn gradle.includedBuilds*.task(':publishMavenJavaPublicationToWebpiecesLocal2Repository')
    publishMavenJavaPublicationToMavenLocal.dependsOn gradle.includedBuilds*.task(':publishMavenJavaPublicationToMavenLocal')

    if(project.hasProperty('projVersion')) {
        if (!project.properties.sonatypeUsername) {
            throw new IllegalStateException("You are missing sonatypeUsername in properties")
        } else if(!project.properties.sonatypePassword) {
            throw new IllegalStateException("You are missing sonatypePassword in properties")
        } else if (!project.hasProperty("signing.keyId")) {
            throw new IllegalStateException("signing.keyId property required for sonas release.  see https://docs.gradle.org/current/userguide/signing_plugin.html")
        }
        publishing {
            repositories {
                maven {
                    name = 'sonatype'
                    url = uri('https://' + project.properties.sonatypeDomain + '/service/local/staging/deploy/maven2/')
                    credentials {
                        username = project.properties.sonatypeUsername
                        password = project.properties.sonatypePassword
                    }
                }
            }
        }
        //To upload to nexus, your key must be uploaded to https://keys.openpgp.org/ as well.
        //generating new key is found in documentation on gradle signing plugin
        signing {
            //let's only sign if releasing to sonatype repo as we have to
            //BUT even if we remove the signing section, we still end up generating *.md5 and *.sha1 so apparently things
            //are still being signed.  This signing section only seems to make the *.asc get generated. Then on top of that,
            //the *asc file is then hashed generating *.asc.md5 and *.asc.sha1 which is annoying.
            sign publishing.publications.mavenJava
        }

        publishMavenJavaPublicationToSonatypeRepository.dependsOn gradle.includedBuilds*.task(':publishMavenJavaPublicationToSonatypeRepository')

//       nexusPublishing {
//           repositories {
//               sonatype {
//                   nexusUrl = uri('https://' + sonatypeDomain + '/service/local/')
//                   snapshotRepositoryUrl = uri('https://' + sonatypeDomain + '/content/repositories/snapshots/')
//                   username = sonatypeUsername
//                   password = sonatypePassword
//               }
//           }
//       }
    }

}

if (!project.hasProperty("projVersion")) {
    ext.sonatypeUsername = "nousername"
    ext.sonatypePassword = "nopassword"
}


//WE should not need this target... (it does this by default but we can't seem to depend on it...wait until we are on 5.3)
//task publishMavenJavaPublicationToMyTempRepository {
//   dependsOn {
//      project.subprojects.collectMany { project -> project.tasks }.findAll { task -> task.name.equals("publishMavenJavaPublicationToMyTempRepository") }
//   }
//}

//Gradle has publishToMavenLocal and publish by default.
//override the publish to throw an exception if projVersion is not set
//task publish {
//   dependsOn {
//      project.subprojects.collectMany { project -> project.tasks }.findAll { task -> task.name.equals("publishMavenJavaPublicationToSonatypeRepository") }
//   }
//}

task printTasks {
    doLast {
        project.tasks.collect { task -> println("task=" + task + " dependsOn=" + task.dependsOn) }
    }
}

//NOTE: The task name MUST BE this (even though I wanted it to be codeCoverage) because codecov.io looks for files
//which are based off this name
task jacocoRootReport(type: JacocoReport) {
    dependsOn = subprojects.test
    additionalSourceDirs.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
    sourceDirectories.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
    classDirectories.setFrom files(subprojects.sourceSets.main.output)
    executionData.setFrom files(subprojects.jacocoTestReport.executionData).filter { f -> f.exists() }
    reports {
        html.required = true
        xml.required = true
        csv.required = false
    }
    onlyIf = {
        true
    }
}

//we don't do java plugin on top level on purpose as it is not a java
//project BUT we need build and clean to work inline with the java projects
if (project.tasks.findByName('build')) {
    build.dependsOn ':jacocoRootReport'
} else {
    task build(dependsOn: ':jacocoRootReport')
}

clean {
    doLast {
        delete "${buildDir}"
    }
}


